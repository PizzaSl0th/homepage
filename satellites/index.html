<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satellites Over Norway - Real-Time 3D Globe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000011;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #globe-container {
            width: 100vw;
            height: 100vh;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.85);
            color: #00ffff;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            border: 1px solid rgba(0, 255, 255, 0.3);
            min-width: 250px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        #info-panel h1 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #ffffff;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        #info-panel p {
            margin: 8px 0;
            font-size: 0.9rem;
        }

        #info-panel span {
            color: #ffffff;
            font-weight: bold;
        }

        #satellite-list {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.8rem;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            padding-top: 10px;
        }

        #satellite-list::-webkit-scrollbar {
            width: 6px;
        }

        #satellite-list::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.5);
        }

        #satellite-list::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 3px;
        }

        .sat-item {
            padding: 4px 0;
            cursor: pointer;
            transition: color 0.2s;
        }

        .sat-item:hover {
            color: #ffffff;
        }

        .sat-item.active {
            color: #ff6666;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.2rem;
            z-index: 200;
        }

        #loading.hidden {
            display: none;
        }

        #satellite-tooltip {
            position: absolute;
            display: none;
            background: rgba(0, 20, 40, 0.95);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 200;
            border: 1px solid rgba(0, 255, 255, 0.5);
            font-size: 0.85rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        #satellite-tooltip strong {
            color: #00ffff;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            z-index: 100;
        }

        .panel-button {
            background: none;
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 10px;
            width: 100%;
            transition: background 0.2s;
        }

        .panel-button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .panel-button.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        #list-toggle {
            display: none;
        }

        #menu-minimize {
            display: none;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h1 {
            margin: 0 !important;
            border: none !important;
            padding: 0 !important;
        }

        #minimize-btn {
            background: none;
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            display: none;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        #minimize-btn:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .panel-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            #info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                padding: 15px;
                max-width: calc(100% - 20px);
            }

            #info-panel h1 {
                font-size: 1.1rem;
            }

            .panel-header {
                margin-bottom: 10px;
                padding-bottom: 10px;
                border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            }

            #minimize-btn {
                display: flex;
            }

            #info-panel p {
                font-size: 0.8rem;
                margin: 5px 0;
            }

            #list-toggle {
                display: block;
            }

            .panel-content {
                max-height: 500px;
                overflow: hidden;
            }

            .panel-content.minimized {
                max-height: 0;
                opacity: 0;
                padding: 0;
                overflow: hidden;
            }

            #satellite-list {
                max-height: 0;
                overflow: hidden;
                padding: 0;
                margin: 0;
                border: none;
                transition: max-height 0.3s ease-out;
            }

            #satellite-list.expanded {
                max-height: 200px;
                overflow-y: auto;
                padding-top: 10px;
                margin-top: 10px;
                border-top: 1px solid rgba(0, 255, 255, 0.3);
            }

            #controls-hint {
                font-size: 0.7rem;
                bottom: 10px;
            }

            #satellite-tooltip {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Loading satellite data...</div>

    <div id="info-panel">
        <div class="panel-header">
            <h1>Norwegian Satellites</h1>
            <button id="minimize-btn" onclick="togglePanel()">−</button>
        </div>
        <div class="panel-content" id="panel-content">
            <p>Satellites tracked: <span id="sat-count">--</span></p>
            <p>Last updated: <span id="last-update">--</span></p>
            <button id="orbit-toggle" class="panel-button" onclick="toggleOrbits()">Show Orbit Lines</button>
            <button id="list-toggle" class="panel-button" onclick="toggleSatelliteList()">Show Satellite List</button>
            <div id="satellite-list"></div>
        </div>
    </div>

    <div id="globe-container"></div>
    <div id="satellite-tooltip"></div>

    <div id="controls-hint">
        Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <!-- Three.js (r128 - stable version with global OrbitControls) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- satellite.js for TLE propagation -->
    <script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js"></script>

    <script>
        // ============================================
        // Constants
        // ============================================
        const EARTH_RADIUS = 1;
        const EARTH_RADIUS_KM = 6371;
        const SCALE_FACTOR = EARTH_RADIUS / EARTH_RADIUS_KM;

        // Norwegian satellites - NORAD IDs
        const NORWEGIAN_SATELLITES = [
            { noradId: 64567, name: 'ARVAKER-2' },
            { noradId: 64566, name: 'ARVAKER-3' },
            { noradId: 63252, name: 'ARVAKER-1' },
            { noradId: 60543, name: 'ARCTIC WEATHER SATELLITE' },
            { noradId: 60531, name: 'HYPSO-2' },
            { noradId: 60423, name: 'ASBM-2' },
            { noradId: 60422, name: 'ASBM-1' },
            { noradId: 55093, name: 'HUYGENS' },
            { noradId: 55015, name: 'BIRKELAND' },
            { noradId: 52161, name: 'ARCSAT-1' },
            { noradId: 51053, name: 'HYPSO-1' },
            { noradId: 48272, name: 'NORSAT-3' },
            { noradId: 40613, name: 'THOR 7' },
            { noradId: 40075, name: 'AISSAT-2' },
            { noradId: 39445, name: 'HINCUBE' },
            { noradId: 36797, name: 'AISSAT-1' },
            { noradId: 36033, name: 'THOR 6' },
            { noradId: 32487, name: 'THOR 5' }
        ];

        // ============================================
        // Global Variables
        // ============================================
        let scene, camera, renderer, controls;
        let earth, satelliteObjects = [];
        let allSatelliteData = [];
        let orbitLines = [];
        let orbitsVisible = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 1000; // Update every second

        // ============================================
        // Toggle Orbit Lines
        // ============================================
        function toggleOrbits() {
            const button = document.getElementById('orbit-toggle');
            orbitsVisible = !orbitsVisible;

            if (orbitsVisible) {
                button.textContent = 'Hide Orbit Lines';
                button.classList.add('active');
                renderOrbitLines();
            } else {
                button.textContent = 'Show Orbit Lines';
                button.classList.remove('active');
                clearOrbitLines();
            }
        }

        function clearOrbitLines() {
            orbitLines.forEach(line => scene.remove(line));
            orbitLines = [];
        }

        function renderOrbitLines() {
            clearOrbitLines();

            if (!orbitsVisible || allSatelliteData.length === 0) return;

            const now = new Date();

            for (const sat of allSatelliteData) {
                try {
                    const satrec = satellite.twoline2satrec(sat.TLE_LINE1, sat.TLE_LINE2);
                    if (!satrec || satrec.error !== 0) continue;

                    // Calculate orbital period in minutes
                    const meanMotion = satrec.no * 1440 / (2 * Math.PI); // rev/day
                    const orbitalPeriodMinutes = 1440 / meanMotion;

                    // Generate points along the orbit (1.5 full orbits for longer trails)
                    const points = [];
                    const numPoints = 270; // More points for smoother curves
                    const orbitMultiplier = 1.5; // Show 1.5 orbits

                    for (let i = 0; i <= numPoints; i++) {
                        const minutesOffset = (i / numPoints) * orbitalPeriodMinutes * orbitMultiplier;
                        const futureDate = new Date(now.getTime() + minutesOffset * 60000);

                        const positionAndVelocity = satellite.propagate(satrec, futureDate);
                        if (!positionAndVelocity.position) continue;

                        const gmst = satellite.gstime(futureDate);
                        const positionGd = satellite.eciToGeodetic(positionAndVelocity.position, gmst);

                        const lat = satellite.degreesLat(positionGd.latitude);
                        const lon = satellite.degreesLong(positionGd.longitude);
                        const alt = positionGd.height;

                        const radius = altitudeToRadius(alt);
                        const pos = latLonToVector3(lat, lon, radius);
                        points.push(pos);
                    }

                    if (points.length > 1) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);

                        // Different colors for GEO vs LEO
                        const isGeo = satrec.no * 1440 / (2 * Math.PI) < 2; // Less than 2 rev/day = GEO
                        const material = new THREE.LineBasicMaterial({
                            color: isGeo ? 0xffaa00 : 0xff6666,
                            transparent: true,
                            opacity: 0.4
                        });

                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        orbitLines.push(line);
                    }
                } catch (error) {
                    console.warn('Error calculating orbit for', sat.OBJECT_NAME);
                }
            }
        }

        // ============================================
        // Toggle Satellite List (for mobile)
        // ============================================
        function toggleSatelliteList() {
            const list = document.getElementById('satellite-list');
            const button = document.getElementById('list-toggle');

            if (list.classList.contains('expanded')) {
                list.classList.remove('expanded');
                button.textContent = 'Show Satellite List';
            } else {
                list.classList.add('expanded');
                button.textContent = 'Hide Satellite List';
            }
        }

        // ============================================
        // Toggle Panel (minimize/expand for mobile)
        // ============================================
        function togglePanel() {
            const content = document.getElementById('panel-content');
            const button = document.getElementById('minimize-btn');

            if (content.classList.contains('minimized')) {
                content.classList.remove('minimized');
                button.textContent = '−';
            } else {
                content.classList.add('minimized');
                button.textContent = '+';
            }
        }

        // ============================================
        // Three.js Scene Setup
        // ============================================
        function initScene() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 12); // Zoomed out to see GEO satellites

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('globe-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1.2;
            controls.maxDistance = 20; // Allow zooming out to see GEO orbit
            controls.rotateSpeed = 0.5;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);

            // Stars background
            createStars();
        }

        // ============================================
        // Create Starfield Background
        // ============================================
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starsVertices, 3));

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // ============================================
        // Create Earth Globe
        // ============================================
        function createEarth() {
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);

            const textureLoader = new THREE.TextureLoader();

            const earthMaterial = new THREE.MeshPhongMaterial({
                map: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-day.jpg'),
                bumpMap: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-topology.png'),
                bumpScale: 0.02,
                specularMap: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-water.png'),
                specular: new THREE.Color(0x333333),
                shininess: 5
            });

            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.01, 64, 64);
            const atmosphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);

            // Add northern lights
            createNorthernLights();
        }

        // ============================================
        // Create Northern Lights (Aurora Borealis)
        // ============================================
        let auroraMaterials = [];

        function createNorthernLights() {
            const auroraRadius = EARTH_RADIUS * 1.03;

            // Create multiple aurora curtains
            for (let i = 0; i < 5; i++) {
                const points = [];
                const colors = [];

                // Create wavy curtain shape around the polar region
                const baseAngle = (i / 5) * Math.PI * 2;
                const numPoints = 50;

                for (let j = 0; j <= numPoints; j++) {
                    const t = j / numPoints;
                    const angle = baseAngle + t * Math.PI * 0.8 - Math.PI * 0.4;

                    // Latitude varies between 60 and 75 degrees north
                    const latVariation = Math.sin(t * Math.PI * 3 + i) * 5;
                    const lat = 67 + latVariation;

                    // Convert to radians
                    const phi = (90 - lat) * (Math.PI / 180);
                    const theta = angle;

                    // Height variation for the wavy effect
                    const heightVar = Math.sin(t * Math.PI * 6 + i * 2) * 0.02;
                    const r = auroraRadius + heightVar;

                    const x = -r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.cos(phi);
                    const z = r * Math.sin(phi) * Math.sin(theta);

                    points.push(new THREE.Vector3(x, y, z));

                    // Color gradient: green to blue to purple
                    const colorT = t + i * 0.2;
                    const r_col = Math.sin(colorT * Math.PI) * 0.3 + 0.2;
                    const g_col = Math.cos(colorT * Math.PI * 0.5) * 0.5 + 0.5;
                    const b_col = Math.sin(colorT * Math.PI + 1) * 0.3 + 0.4;
                    colors.push(r_col, g_col, b_col);
                }

                // Create the aurora curtain as a tube/ribbon
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.015, 8, false);

                const auroraMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.2, 0.8, 0.4),
                    transparent: true,
                    opacity: 0.3 + Math.random() * 0.2,
                    side: THREE.DoubleSide
                });

                auroraMaterials.push(auroraMaterial);

                const aurora = new THREE.Mesh(tubeGeometry, auroraMaterial);
                scene.add(aurora);
            }

            // Add glowing particles for sparkle effect
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = [];

            for (let i = 0; i < particleCount; i++) {
                const lat = 60 + Math.random() * 20; // 60-80 degrees north
                const lon = Math.random() * 360;
                const alt = 0.02 + Math.random() * 0.04;

                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                const r = EARTH_RADIUS + alt;

                particlePositions.push(
                    -r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );
            }

            particleGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(particlePositions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ff88,
                size: 0.008,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        function animateAurora(time) {
            // Animate aurora opacity for shimmering effect
            auroraMaterials.forEach((material, i) => {
                material.opacity = 0.2 + Math.sin(time * 0.001 + i * 0.5) * 0.15;
                // Shift colors slightly
                const hue = (0.3 + Math.sin(time * 0.0005 + i * 0.3) * 0.1);
                material.color.setHSL(hue, 0.8, 0.5);
            });
        }

        // ============================================
        // Create orbit rings to help visualize altitude
        // ============================================
        function createOrbitRings() {
            // LEO orbit ring (~600km)
            const leoRadius = altitudeToRadius(600);
            const leoGeometry = new THREE.RingGeometry(leoRadius - 0.001, leoRadius + 0.001, 64);
            const leoMaterial = new THREE.MeshBasicMaterial({
                color: 0xff3333,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const leoRing = new THREE.Mesh(leoGeometry, leoMaterial);
            leoRing.rotation.x = Math.PI / 2;
            scene.add(leoRing);

            // GEO orbit ring (~36000km) - scaled down for visibility
            const geoRadius = altitudeToRadius(35786);
            const geoGeometry = new THREE.RingGeometry(geoRadius - 0.002, geoRadius + 0.002, 64);
            const geoMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const geoRing = new THREE.Mesh(geoGeometry, geoMaterial);
            geoRing.rotation.x = Math.PI / 2;
            scene.add(geoRing);
        }

        // ============================================
        // Coordinate Conversion Functions
        // ============================================
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            return new THREE.Vector3(x, y, z);
        }

        function altitudeToRadius(altitudeKm) {
            return EARTH_RADIUS + (altitudeKm * SCALE_FACTOR);
        }

        // ============================================
        // Satellite Data Fetching
        // ============================================
        // Helper function to fetch with timeout
        async function fetchWithTimeout(url, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        async function fetchSatelliteData() {
            const loadingEl = document.getElementById('loading');
            const satellites = [];

            loadingEl.textContent = 'Fetching Norwegian satellites...';

            // Fetch each satellite individually by NORAD ID using TLE format
            // Process in parallel batches
            const batchSize = 5;

            for (let i = 0; i < NORWEGIAN_SATELLITES.length; i += batchSize) {
                const batch = NORWEGIAN_SATELLITES.slice(i, i + batchSize);

                const promises = batch.map(async (satInfo) => {
                    // Fetch TLE format (3 lines: name, line1, line2)
                    const url = `https://celestrak.org/NORAD/elements/gp.php?CATNR=${satInfo.noradId}&FORMAT=TLE`;

                    try {
                        let response;
                        try {
                            response = await fetchWithTimeout(url, 10000);
                        } catch (e) {
                            response = await fetchWithTimeout('https://corsproxy.io/?' + encodeURIComponent(url), 10000);
                        }

                        if (response && response.ok) {
                            const text = await response.text();
                            const lines = text.trim().split('\n');

                            if (lines.length >= 3) {
                                return {
                                    OBJECT_NAME: lines[0].trim(),
                                    TLE_LINE1: lines[1].trim(),
                                    TLE_LINE2: lines[2].trim(),
                                    NORAD_CAT_ID: satInfo.noradId
                                };
                            }
                        }
                    } catch (e) {
                        console.warn(`Failed to fetch ${satInfo.name}:`, e.message);
                    }
                    return null;
                });

                const results = await Promise.all(promises);
                results.filter(r => r !== null).forEach(sat => satellites.push(sat));

                loadingEl.textContent = `Loaded ${satellites.length}/${NORWEGIAN_SATELLITES.length} satellites...`;
            }

            console.log(`Successfully loaded ${satellites.length} Norwegian satellites`);
            return satellites;
        }

        // ============================================
        // Satellite Position Calculation using TLE
        // ============================================
        function calculateSatellitePosition(sat, date) {
            try {
                if (!sat.TLE_LINE1 || !sat.TLE_LINE2) {
                    console.warn('Missing TLE data for', sat.OBJECT_NAME);
                    return null;
                }

                // Parse TLE and create satellite record
                const satrec = satellite.twoline2satrec(sat.TLE_LINE1, sat.TLE_LINE2);

                if (!satrec || satrec.error !== 0) {
                    console.warn(`TLE parse error for ${sat.OBJECT_NAME}`);
                    return null;
                }

                // Propagate to current time
                const positionAndVelocity = satellite.propagate(satrec, date);

                if (!positionAndVelocity.position) {
                    return null;
                }

                // Convert to geodetic coordinates
                const gmst = satellite.gstime(date);
                const positionGd = satellite.eciToGeodetic(positionAndVelocity.position, gmst);

                return {
                    latitude: satellite.degreesLat(positionGd.latitude),
                    longitude: satellite.degreesLong(positionGd.longitude),
                    altitude: positionGd.height
                };
            } catch (error) {
                console.warn('Position calculation error for', sat.OBJECT_NAME, ':', error.message);
                return null;
            }
        }

        // ============================================
        // Calculate All Satellite Positions
        // ============================================
        function calculateAllSatellitePositions(satellites, date) {
            const result = [];

            for (const sat of satellites) {
                const position = calculateSatellitePosition(sat, date);
                if (position) {
                    result.push({
                        name: sat.OBJECT_NAME,
                        noradId: sat.NORAD_CAT_ID,
                        ...position
                    });
                }
            }

            return result;
        }

        // ============================================
        // Create 3D Satellite Model
        // ============================================
        function createSatelliteModel(isGeo) {
            const group = new THREE.Group();
            const scale = isGeo ? 0.12 : 0.06;

            // Main body (box shape)
            const bodyGeometry = new THREE.BoxGeometry(scale, scale * 0.6, scale * 0.6);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: isGeo ? 0xcccccc : 0xaaaaaa,
                shininess: 30
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);

            // Solar panels
            const panelGeometry = new THREE.BoxGeometry(scale * 2.5, scale * 0.05, scale * 0.8);
            const panelMaterial = new THREE.MeshPhongMaterial({
                color: isGeo ? 0x1a237e : 0x0d47a1,
                shininess: 50,
                emissive: isGeo ? 0x1a237e : 0x0d47a1,
                emissiveIntensity: 0.2
            });

            // Left panel
            const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            leftPanel.position.x = -scale * 1.5;
            group.add(leftPanel);

            // Right panel
            const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            rightPanel.position.x = scale * 1.5;
            group.add(rightPanel);

            // Antenna dish (for GEO satellites)
            if (isGeo) {
                const dishGeometry = new THREE.ConeGeometry(scale * 0.4, scale * 0.3, 16, 1, true);
                const dishMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });
                const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                dish.position.y = scale * 0.5;
                dish.rotation.x = Math.PI;
                group.add(dish);
            }

            // Glowing indicator light
            const lightGeometry = new THREE.SphereGeometry(scale * 0.15, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({
                color: isGeo ? 0xffaa00 : 0xff3333,
                transparent: true,
                opacity: 0.9
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.z = scale * 0.4;
            group.add(light);

            return group;
        }

        // ============================================
        // Satellite Rendering
        // ============================================
        function renderSatellites(satellites) {
            // Clear existing satellites
            satelliteObjects.forEach(obj => scene.remove(obj));
            satelliteObjects = [];

            for (const sat of satellites) {
                const radius = altitudeToRadius(sat.altitude);
                const position = latLonToVector3(sat.latitude, sat.longitude, radius);

                // GEO satellites (THOR series) are at ~36000km, LEO at ~400-800km
                const isGeo = sat.altitude > 30000;

                // Create 3D satellite model
                const satelliteModel = createSatelliteModel(isGeo);
                satelliteModel.position.copy(position);

                // Orient satellite to face Earth (nadir pointing)
                satelliteModel.lookAt(0, 0, 0);

                satelliteModel.userData = {
                    name: sat.name,
                    noradId: sat.noradId,
                    altitude: sat.altitude,
                    lat: sat.latitude,
                    lon: sat.longitude,
                    isGeo: isGeo
                };

                scene.add(satelliteModel);
                satelliteObjects.push(satelliteModel);
            }

            // Update UI
            document.getElementById('sat-count').textContent = satellites.length;

            // Update satellite list
            updateSatelliteList(satellites);
        }

        function updateSatelliteList(satellites) {
            const listEl = document.getElementById('satellite-list');
            listEl.innerHTML = satellites
                .sort((a, b) => a.name.localeCompare(b.name))
                .map(sat => `<div class="sat-item" data-norad="${sat.noradId}">${sat.name}</div>`)
                .join('');

            // Add click handlers
            listEl.querySelectorAll('.sat-item').forEach(item => {
                item.addEventListener('click', () => {
                    const noradId = parseInt(item.dataset.norad);
                    focusOnSatellite(noradId);
                });
            });
        }

        function focusOnSatellite(noradId) {
            const satObj = satelliteObjects.find(obj => obj.userData.noradId === noradId);
            if (satObj) {
                const isGeo = satObj.userData.isGeo;

                // Calculate appropriate zoom distance based on satellite type
                // GEO satellites are much further out, so we need to zoom out more
                const satDistance = satObj.position.length();
                const zoomDistance = isGeo ? satDistance + 2 : Math.max(satDistance + 0.5, 2.5);

                // Position camera to look at the satellite from outside its orbit
                const direction = satObj.position.clone().normalize();
                const cameraPos = direction.multiplyScalar(zoomDistance);

                camera.position.copy(cameraPos);
                controls.target.copy(satObj.position);
                controls.update();
            }
        }

        // ============================================
        // Mouse Hover Interactivity
        // ============================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersections with all children of satellite groups
            const allMeshes = [];
            satelliteObjects.forEach(group => {
                group.traverse(child => {
                    if (child.isMesh) {
                        child.userData.parentGroup = group;
                        allMeshes.push(child);
                    }
                });
            });

            const intersects = raycaster.intersectObjects(allMeshes);
            const tooltip = document.getElementById('satellite-tooltip');

            if (intersects.length > 0) {
                // Get the parent group's userData
                const parentGroup = intersects[0].object.userData.parentGroup;
                const sat = parentGroup ? parentGroup.userData : intersects[0].object.userData;

                if (sat && sat.name) {
                    const orbitType = sat.isGeo ? 'Geostationary' : 'Low Earth Orbit';
                    tooltip.innerHTML = `
                        <strong>${sat.name}</strong><br>
                        NORAD ID: ${sat.noradId}<br>
                        Orbit: ${orbitType}<br>
                        Altitude: ${sat.altitude.toFixed(1)} km<br>
                        Lat: ${sat.lat.toFixed(2)}° | Lon: ${sat.lon.toFixed(2)}°
                    `;
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 15 + 'px';
                    tooltip.style.top = event.clientY + 15 + 'px';

                    document.body.style.cursor = 'pointer';
                }
            } else {
                tooltip.style.display = 'none';
                document.body.style.cursor = 'default';
            }
        }

        // ============================================
        // Window Resize Handler
        // ============================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // Animation Loop
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();

            // Animate aurora
            animateAurora(now);

            // Update satellite positions every second
            if (now - lastUpdateTime > UPDATE_INTERVAL && allSatelliteData.length > 0) {
                const currentDate = new Date();
                const positions = calculateAllSatellitePositions(allSatelliteData, currentDate);
                renderSatellites(positions);

                document.getElementById('last-update').textContent =
                    currentDate.toLocaleTimeString();

                lastUpdateTime = now;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============================================
        // Initialization
        // ============================================
        async function init() {
            initScene();
            createEarth();
            createOrbitRings();

            // Event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();

            // Fetch satellite data
            allSatelliteData = await fetchSatelliteData();
            document.getElementById('loading').classList.add('hidden');

            console.log(`Loaded ${allSatelliteData.length} Norwegian satellites`);

            // Initial render
            if (allSatelliteData.length > 0) {
                const currentDate = new Date();
                const positions = calculateAllSatellitePositions(allSatelliteData, currentDate);
                renderSatellites(positions);
                document.getElementById('last-update').textContent =
                    currentDate.toLocaleTimeString();
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
